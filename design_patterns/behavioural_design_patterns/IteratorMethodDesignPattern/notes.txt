Iterator Pattern Motivation

Suppose you have a collection, such as an array or list, and you need to provide a mechanism for accessing its elements. Without the iterator pattern, the client code needs to understand how the collection is structured, and different collections would require different methods to traverse them. 

Problem: How to access elements in a collection without exposing its internal representation.

Solution: The iterator pattern provides a way to traverse a collection without revealing its underlying structure, offering a uniform interface for traversal.

Structure:

    1. Iterator: Interface for traversing a collection.

    2. Collection: Holds the elements and provides an iterator.

Iterator Pattern Benefits:

    1. Separation of Concerns: The traversal logic is separated from the collection itself, allowing you to change one without affecting the other.

    2. Uniform Interface: The same interface (Iterator) is used for traversing.

    3. Simplified Client Code: The client doesn't need to know the underlying data structure, reducing coupling and making the code easier to maintain.

    4. Multiple traversal Strategies: You can implement multiple types of iterators (e.g., forward, backward, filtered) without changing the collection.
